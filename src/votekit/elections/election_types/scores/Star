from models import Election
from pref_profile import PreferenceProfile
from election_state import ElectionState
from utils import (
    score_profile_from_ballot_scores,
    remove_and_condense,
)
from typing import Optional, List, Dict, Tuple

class STAR(Election):
    """
    STAR (Score Then Automatic Runoff) voting method. Voters score each candidate with
    any numerical value up to :math:`L`, where :math:`L` is a user-specified maximum score,
    using votekit.Ballot objects with score dictionaries. Scores may be positive or negative,
    and missing scores are treated as 0. The two candidates with the highest total scores
    advance to an automatic runoff, where the candidate preferred by more voters (based on
    higher scores) wins. Ties in the runoff are resolved using the specified tiebreaker.

    Args:
        profile (PreferenceProfile): Profile from votekit, containing a list of Ballot objects
            with score dictionaries mapping candidates to scores and optional weights.
        L (float, optional): Maximum score per candidate. Defaults to 5.
        tiebreak (str, optional): Tiebreak method to use. Options are None or 'most_top_ratings'.
            If 'most_top_ratings', the finalist with more ballots assigning the maximum score wins.
            If None, a tie results in no winner (None). Defaults to None.

    Raises:
        ValueError: If L is not positive or there are fewer than two candidates.
        TypeError: If ballots lack score dictionaries or have non-positive weights.

    Returns:
        dict: A dictionary containing:
            - winner (str or None): The winning candidate, or None if a tie occurs and tiebreak is None.
            - finalists (tuple): The two candidates in the runoff.
            - scores (dict): Total scores per candidate.
            - runoff (dict): Runoff vote counts for finalists and "No Preference".
    """

    def __init__(
        self,
        profile: PreferenceProfile,
        L: float = 5,
        tiebreak: Optional[str] = None,
    ):
        if L <= 0:
            raise ValueError("L must be positive.")
        self.L = L
        if tiebreak not in [None, 'most_top_ratings']:
            raise ValueError("tiebreak must be None or 'most_top_ratings'.")
        self.tiebreak = tiebreak
        self._validate_profile(profile)
        super().__init__(
            profile, score_function=score_profile_from_ballot_scores, sort_high_low=True
        )

    def _validate_profile(self, profile: PreferenceProfile):
        """
        Ensures that every ballot has a score dictionary and weights are valid.

        Args:
            profile (PreferenceProfile): Profile from votekit to validate, containing Ballot objects.

        Raises:
            ValueError: Fewer than two candidates provided (STAR requires at least two).
            TypeError: Ballots lack score dictionaries or have non-positive weights.
        """
        if len(profile.candidates_cast) <= 1:
            raise ValueError("STAR requires at least two candidates.")
        for b in profile.ballots:
            if b.scores is None:
                raise TypeError("All ballots must have score dictionary.")
            elif any(score > self.L for score in b.scores.values()):
                raise TypeError(
                    f"Ballot {b} violates score limit {self.L} per candidate."
                )
            elif hasattr(b, 'weight') and b.weight <= 0:
                raise TypeError(f"Ballot {b} must have positive weight.")

    def _tiebreak_most_top_ratings(self, finalists: List[str], ballots: List) -> Optional[str]:
        """
        Resolves a tie by selecting the finalist with more ballots assigning the maximum score.

        Args:
            finalists (List[str]): The two candidates in the runoff.
            ballots (List): List of votekit.Ballot objects from the PreferenceProfile.

        Returns:
            Optional[str]: The winning candidate, or None if the tie persists.
        """
        top_score = max((score for b in ballots for score in b.scores.values()), default=0)
        top_ratings = {f: 0 for f in finalists}
        for ballot in ballots:
            weight = getattr(ballot, 'weight', 1)
            for f in finalists:
                if ballot.scores.get(f, 0) == top_score:
                    top_ratings[f] += weight
        if top_ratings[finalists[0]] != top_ratings[finalists[1]]:
            return max(top_ratings, key=top_ratings.get)
        return None

    def _is_finished(self) -> bool:
        """
        Checks if the election is finished (single-round election).

        Returns:
            bool: True if the election has completed (two states exist), False otherwise.
        """
        return len(self.election_states) == 2

    def _run_step(
        self, profile: PreferenceProfile, prev_state: ElectionState, store_states: bool = False
    ) -> PreferenceProfile:
        """
        Run one step of the STAR election.

        Args:
            profile (PreferenceProfile): Profile of votekit.Ballot objects.
            prev_state (ElectionState): The previous ElectionState.
            store_states (bool, optional): True if election_states should be updated.
                Defaults to False.

        Returns:
            PreferenceProfile: The profile after removing the elected candidate.
        """
        # Compute total scores
        scores = self.score_function(profile) if self.score_function else {}
        sorted_candidates = sorted(scores, key=scores.get, reverse=True)
        finalist1, finalist2 = sorted_candidates[:2]
        finalists = (finalist1, finalist2)

        # Runoff: count preferences between finalists
        runoff_counts = {finalist1: 0, finalist2: 0, "No Preference": 0}
        for ballot in profile.ballots:
            weight = getattr(ballot, 'weight', 1)
            score1 = ballot.scores.get(finalist1, 0)
            score2 = ballot.scores.get(finalist2, 0)
            if score1 > score2:
                runoff_counts[finalist1] += weight
            elif score2 > score1:
                runoff_counts[finalist2] += weight
            else:
                runoff_counts["No Preference"] += weight

        # Determine winner
        if runoff_counts[finalist1] > runoff_counts[finalist2]:
            winner = finalist1
        elif runoff_counts[finalist2] > runoff_counts[finalist1]:
            winner = finalist2
        else:
            winner = None
            if self.tiebreak == 'most_top_ratings':
                winner = self._tiebreak_most_top_ratings([finalist1, finalist2], profile.ballots)

        elected = [(winner,)] if winner else []
        remaining = [c for c in profile.candidates_cast if c != winner]

        # Update profile by removing elected candidate
        elected_cands = [c for s in elected for c in s]
        new_profile = remove_and_condense(elected_cands, profile)

        if store_states:
            new_state = ElectionState(
                round_number=1,
                remaining=remaining,
                elected=elected,
                scores=scores,
                tiebreaks={} if winner else {f"{finalist1},{finalist2}": None},
                metadata={"runoff_counts": runoff_counts}
            )
            self.election_states.append(new_state)

        return new_profile

    def run_election(self) -> Dict:
        """
        Run the STAR election and return the results.

        Returns:
            dict: A dictionary containing:
                - winner (str or None): The winning candidate, or None if a tie occurs and tiebreak is None.
                - finalists (tuple): The two candidates in the runoff.
                - scores (dict): Total scores per candidate.
                - runoff (dict): Runoff vote counts for finalists and "No Preference".
        """
        super().run_election()
        final_state = self.election_states[-1] if self.election_states else None
        if not final_state:
            return {
                "winner": None,
                "finalists": (),
                "scores": {},
                "runoff": {}
            }
        winner = final_state.elected[0][0] if final_state.elected else None
        finalists = tuple(final_state.scores.keys()[:2]) if len(final_state.scores) >= 2 else tuple(final_state.scores.keys())
        return {
            "winner": winner,
            "finalists": finalists,
            "scores": final_state.scores,
            "runoff": final_state.metadata.get("runoff_counts", {})
        }
