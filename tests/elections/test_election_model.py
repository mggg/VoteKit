from votekit.elections import ElectionState, Election
from votekit import PreferenceProfile, Ballot
from votekit.utils import score_dict_to_ranking
import pandas as pd
import pytest


class TestElection(Election):
    __test__ = False  # prevents Pytest from trying to collect this
    """
    Elect the first person observed on first ballot. Eliminate second person. Rest remain.
    Discard entire ballot. Repeat for one more round. Scores are just index of letter in string 
    ABCDEF
    """

    def __init__(self, profile: PreferenceProfile, sort_high_low: bool = True):
        def score(profile: PreferenceProfile) -> dict:
            score_dict = {c: 0 for c in profile.candidates}
            for ballot in profile.ballots:
                assert ballot.ranking is not None
                for s in ballot.ranking:
                    for c in s:
                        score_dict[c] += "ABCDEF".index(c)
            return score_dict

        super().__init__(profile, score_function=score, sort_high_low=sort_high_low)

    def _validate_profile(self, profile):
        for ballot in profile.ballots:
            if not ballot.ranking:
                raise TypeError("Ballots must having rankings.")

    def _is_finished(self):
        # 2 round election, so 3 states
        if len(self.election_states) == 3:
            return True
        return False

    def _run_step(
        self, profile: PreferenceProfile, prev_state: ElectionState, store_states=False
    ) -> PreferenceProfile:
        """
        Run one step of an election from the given profile and previous state.

        Args:
            profile (PreferenceProfile): Profile of ballots.
            prev_state (ElectionState): The previous ElectionState.
            store_states (bool, optional): True if `self.election_states` should be updated with the
                ElectionState generated by this round. This should only be True when used by
                `self._run_election()`. Defaults to False.

        Returns:
            PreferenceProfile: The profile of ballots after the round is completed.
        """

        new_profile = PreferenceProfile(ballots=profile.ballots[1:])

        if store_states:
            assert profile.ballots[0].ranking is not None
            elected = list(profile.ballots[0].ranking[0])[0]
            eliminated = list(profile.ballots[0].ranking[1])[0]
            remaining = list(profile.candidates)
            remaining.remove(elected)
            remaining.remove(eliminated)
            assert self.score_function is not None
            scores = self.score_function(new_profile)

            new_state = ElectionState(
                round_number=(prev_state.round_number + 1),
                remaining=score_dict_to_ranking(scores, self.sort_high_low),
                elected=tuple([frozenset(elected)]),
                eliminated=tuple([frozenset(eliminated)]),
                scores=scores,
            )

            self.election_states.append(new_state)

        return new_profile


profile = PreferenceProfile(
    ballots=[
        Ballot(ranking=[{"A"}, {"B"}]),
        Ballot(ranking=[{"C"}, {"D"}]),
        Ballot(ranking=[{"E"}, {"F"}]),
    ]
)
profile_1 = PreferenceProfile(
    ballots=[Ballot(ranking=[{"C"}, {"D"}]), Ballot(ranking=[{"E"}, {"F"}])]
)
profile_2 = PreferenceProfile(ballots=[Ballot(ranking=[{"E"}, {"F"}])])

states = [
    ElectionState(
        remaining=(
            frozenset({"F"}),
            frozenset({"E"}),
            frozenset({"D"}),
            frozenset({"C"}),
            frozenset({"B"}),
            frozenset({"A"}),
        ),
        scores={"A": 0, "B": 1, "C": 2, "D": 3, "E": 4, "F": 5},
    ),
    ElectionState(
        round_number=1,
        remaining=(
            frozenset({"F"}),
            frozenset({"E"}),
            frozenset({"D"}),
            frozenset({"C"}),
        ),
        elected=(frozenset({"A"}),),
        eliminated=(frozenset({"B"}),),
        scores={"C": 2, "D": 3, "E": 4, "F": 5},
    ),
    ElectionState(
        round_number=2,
        remaining=(frozenset({"F"}), frozenset({"E"})),
        elected=(frozenset({"C"}),),
        eliminated=(frozenset({"D"}),),
        scores={"E": 4, "F": 5},
    ),
]
e = TestElection(profile)


def test_election_init():
    assert isinstance(e, Election)
    assert e._profile == profile
    assert e.length == 2


def test_election_state_list():
    assert e.election_states == states
    assert e.length == len(e.election_states) - 1


def test_get_profile():
    assert e.get_profile() == e.get_profile(2)  # default behavior is get last round
    assert e.get_profile(0) == profile
    assert e.get_profile(1) == profile_1
    assert e.get_profile(2) == profile_2
    assert e.get_profile(-3) == profile
    assert e.get_profile(-2) == profile_1
    assert e.get_profile(-1) == profile_2


def test_get_profile_errors():
    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_profile(-4)  # supports -3 through 2

    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_profile(3)  # supports -3 through 2


def test_get_step():
    assert e.get_step() == e.get_step(2)  # default behavior is get last round
    assert e.get_step(0) == (profile, states[0])
    assert e.get_step(1) == (profile_1, states[1])
    assert e.get_step(2) == (profile_2, states[2])
    assert e.get_step(-3) == (profile, states[0])
    assert e.get_step(-2) == (profile_1, states[1])
    assert e.get_step(-1) == (profile_2, states[2])


def test_get_step_errors():
    with pytest.raises(IndexError):
        e.get_step(-4)  # supports -3 through 2

    with pytest.raises(IndexError):
        e.get_step(3)  # supports -3 through 2


def test_get_elected():
    assert e.get_elected() == e.get_elected(2)  # default behavior is get last round
    assert e.get_elected(0) == tuple()
    assert e.get_elected(1) == ({"A"},)
    assert e.get_elected(2) == ({"A"}, {"C"})
    assert e.get_elected(-3) == tuple()
    assert e.get_elected(-2) == ({"A"},)
    assert e.get_elected(-1) == ({"A"}, {"C"})


def test_get_elected_errors():
    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_elected(-4)  # supports -3 through 2

    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_elected(3)  # supports -3 through 2


def test_get_eliminated():
    assert e.get_eliminated() == e.get_eliminated(
        2
    )  # default behavior is get last round
    assert e.get_eliminated(0) == tuple()
    assert e.get_eliminated(1) == ({"B"},)
    assert e.get_eliminated(2) == ({"D"}, {"B"})
    assert e.get_eliminated(-3) == tuple()
    assert e.get_eliminated(-2) == ({"B"},)
    assert e.get_eliminated(-1) == ({"D"}, {"B"})


def test_get_eliminated_errors():
    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_eliminated(-4)  # supports -3 through 2

    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_eliminated(3)  # supports -3 through 2


def test_get_remaining():
    assert e.get_remaining() == e.get_remaining(2)  # default behavior is get last round
    assert e.get_remaining(0) == ({"F"}, {"E"}, {"D"}, {"C"}, {"B"}, {"A"})
    assert e.get_remaining(1) == ({"F"}, {"E"}, {"D"}, {"C"})
    assert e.get_remaining(2) == ({"F"}, {"E"})
    assert e.get_remaining(-3) == ({"F"}, {"E"}, {"D"}, {"C"}, {"B"}, {"A"})
    assert e.get_remaining(-2) == ({"F"}, {"E"}, {"D"}, {"C"})
    assert e.get_remaining(-1) == ({"F"}, {"E"})


def test_get_remaining_errors():
    with pytest.raises(IndexError):
        e.get_remaining(-4)  # supports -3 through 2

    with pytest.raises(IndexError):
        e.get_remaining(3)  # supports -3 through 2


def test_get_ranking():
    assert e.get_ranking() == e.get_ranking(2)  # default behavior is get last round
    assert e.get_ranking(0) == ({"F"}, {"E"}, {"D"}, {"C"}, {"B"}, {"A"})
    assert e.get_ranking(1) == ({"A"}, {"F"}, {"E"}, {"D"}, {"C"}, {"B"})
    assert e.get_ranking(2) == ({"A"}, {"C"}, {"F"}, {"E"}, {"D"}, {"B"})
    assert e.get_ranking(-3) == ({"F"}, {"E"}, {"D"}, {"C"}, {"B"}, {"A"})
    assert e.get_ranking(-2) == ({"A"}, {"F"}, {"E"}, {"D"}, {"C"}, {"B"})
    assert e.get_ranking(-1) == ({"A"}, {"C"}, {"F"}, {"E"}, {"D"}, {"B"})


def test_get_ranking_errors():
    with pytest.raises(IndexError):
        e.get_ranking(-4)  # supports -3 through 2

    with pytest.raises(IndexError):
        e.get_ranking(3)  # supports -3 through 2


def test_get_status_df():
    round_0 = pd.DataFrame(
        {"Status": ["Remaining"] * 6, "Round": [0] * 6},
        index=["F", "E", "D", "C", "B", "A"],
    )

    round_1 = pd.DataFrame(
        {
            "Status": [
                "Elected",
                "Remaining",
                "Remaining",
                "Remaining",
                "Remaining",
                "Eliminated",
            ],
            "Round": [1] * 6,
        },
        index=["A", "F", "E", "D", "C", "B"],
    )

    round_2 = pd.DataFrame(
        {
            "Status": [
                "Elected",
                "Elected",
                "Remaining",
                "Remaining",
                "Eliminated",
                "Eliminated",
            ],
            "Round": [1, 2, 2, 2, 2, 1],
        },
        index=["A", "C", "F", "E", "D", "B"],
    )

    assert e.get_status_df().equals(
        e.get_status_df(2)
    )  # default behavior is get last round
    assert e.get_status_df(0).equals(round_0)
    assert e.get_status_df(1).equals(round_1)
    assert e.get_status_df(2).equals(round_2)


def test_get_status_df_errors():
    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_status_df(-4)  # supports -3 through 2
    with pytest.raises(IndexError, match="round_number out of range."):
        e.get_status_df(3)  # supports -3 through 2


def test_score_sort():
    e_low_high = TestElection(profile, sort_high_low=False)

    low_high_states = [
        ElectionState(
            remaining=(
                frozenset({"A"}),
                frozenset({"B"}),
                frozenset({"C"}),
                frozenset({"D"}),
                frozenset({"E"}),
                frozenset({"F"}),
            ),
            scores={"A": 0, "B": 1, "C": 2, "D": 3, "E": 4, "F": 5},
        ),
        ElectionState(
            round_number=1,
            remaining=(
                frozenset({"C"}),
                frozenset({"D"}),
                frozenset({"E"}),
                frozenset({"F"}),
            ),
            elected=(frozenset({"A"}),),
            eliminated=(frozenset({"B"}),),
            scores={"C": 2, "D": 3, "E": 4, "F": 5},
        ),
        ElectionState(
            round_number=2,
            remaining=(frozenset({"E"}), frozenset({"F"})),
            elected=(frozenset({"C"}),),
            eliminated=(frozenset({"D"}),),
            scores={"E": 4, "F": 5},
        ),
    ]

    round_2 = pd.DataFrame(
        {
            "Status": [
                "Elected",
                "Elected",
                "Remaining",
                "Remaining",
                "Eliminated",
                "Eliminated",
            ],
            "Round": [1, 2, 2, 2, 2, 1],
        },
        index=["A", "C", "E", "F", "D", "B"],
    )

    assert e_low_high.election_states == low_high_states
    assert e_low_high.get_status_df(2).equals(round_2)


def test_print():
    assert (
        str(e)
        == "       Status  Round\nA     Elected      1\nC     Elected      2\nF   Remaining      2\nE   Remaining      2\nD  Eliminated      2\nB  Eliminated      1"
    )
